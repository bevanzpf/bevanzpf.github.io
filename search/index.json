[{"content":"é¡¹ç›®ä¸Šå¤§é‡ä½¿ç”¨Redisåšç¼“å­˜ï¼Œå‰é˜µå­è¿˜å› ä¸ºgo-redisè¿™ä¸ªå®¢æˆ·ç«¯çš„ä¸€äº›é»˜è®¤é…ç½®è¸©äº†äº›å‘ï¼Œæ‰€ä»¥å†³å®šæŠ½å‡ºæ—¶é—´è¯»è¯»å®ƒçš„æºç ï¼Œå¥½å¥½äº†è§£ä¸€ä¸‹ä¸€äº›å…³é”®åŠŸèƒ½ï¼ˆä¾‹å¦‚ï¼šè¿æ¥æ± ï¼Œrediså‘½ä»¤ï¼‰çš„å®ç°ã€‚\nä¸»è¦ç»“æ„å›¾ æ•´ä¸ªrediså®¢æˆ·ç«¯åˆ†ä¸ºä¸¤ä¸ªä¸»è¦çš„éƒ¨åˆ†ï¼Œä¸€ä¸ªæ˜¯cmdableå®ç°çš„å„ç§Rediså‘½ä»¤æ“ä½œï¼Œå¦ä¸€éƒ¨åˆ†æ˜¯connPoolå®ç°çš„è¿æ¥æ± ç®¡ç†åŠŸèƒ½ã€‚\nå¯åŠ¨è¿‡ç¨‹ func NewClient(opt *Options) *Client { opt.init() c := Client{ baseClient: newBaseClient(opt, newConnPool(opt)), ctx: context.Background(), } c.cmdable = c.Process return \u0026amp;c }  åˆå§‹åŒ–é…ç½® é¦–å…ˆåˆå§‹åŒ–é…ç½®å¯¹è±¡optionsï¼Œè¿™ä¸ªstructä¸»è¦åŒ…å«Redisè¿æ¥æ–¹å¼ï¼Œå„ç§è¯»å†™è¶…æ—¶ä»¥åŠè¿æ¥æ± çš„ç›¸å…³å±æ€§è®¾ç½®ï¼Œåœ¨opt.initä¸­å¯¹å„ä¸ªå±æ€§è¿›è¡Œè®¾ç½®ï¼Œå¦‚æœè®¾ç½®é¡¹æ²¡æœ‰æŒ‡å®šåˆ™å¡«å……é»˜è®¤å€¼ã€‚\ntype Options struct { // The network type, either tcp or unix. // Default is tcp. Network string // host:port address. Addr string // Dialer creates new network connection and has priority over // Network and Addr options. Dialer func(ctx context.Context, network, addr string) (net.Conn, error) // Hook that is called when new connection is established. OnConnect func(ctx context.Context, cn *Conn) error // Use the specified Username to authenticate the current connection // with one of the connections defined in the ACL list when connecting // to a Redis 6.0 instance, or greater, that is using the Redis ACL system. Username string // Optional password. Must match the password specified in the // requirepass server configuration option (if connecting to a Redis 5.0 instance, or lower), // or the User Password when connecting to a Redis 6.0 instance, or greater, // that is using the Redis ACL system. Password string // Database to be selected after connecting to the server. DB int // Maximum number of retries before giving up. // Default is to not retry failed commands. MaxRetries int // Minimum backoff between each retry. // Default is 8 milliseconds; -1 disables backoff. MinRetryBackoff time.Duration // Maximum backoff between each retry. // Default is 512 milliseconds; -1 disables backoff. MaxRetryBackoff time.Duration // Dial timeout for establishing new connections. // Default is 5 seconds. DialTimeout time.Duration // Timeout for socket reads. If reached, commands will fail // with a timeout instead of blocking. Use value -1 for no timeout and 0 for default. // Default is 3 seconds. ReadTimeout time.Duration // Timeout for socket writes. If reached, commands will fail // with a timeout instead of blocking. // Default is ReadTimeout. WriteTimeout time.Duration // Maximum number of socket connections. // Default is 10 connections per every CPU as reported by runtime.NumCPU. PoolSize int // Minimum number of idle connections which is useful when establishing // new connection is slow. MinIdleConns int // Connection age at which client retires (closes) the connection. // Default is to not close aged connections. MaxConnAge time.Duration // Amount of time client waits for connection if all connections // are busy before returning an error. // Default is ReadTimeout + 1 second. PoolTimeout time.Duration // Amount of time after which client closes idle connections. // Should be less than server's timeout. // Default is 5 minutes. -1 disables idle timeout check. IdleTimeout time.Duration // Frequency of idle checks made by idle connections reaper. // Default is 1 minute. -1 disables idle connections reaper, // but idle connections are still discarded by the client // if IdleTimeout is set. IdleCheckFrequency time.Duration // Enables read only queries on slave nodes. readOnly bool // TLS Config to use. When set TLS will be negotiated. TLSConfig *tls.Config // Limiter interface used to implemented circuit breaker or rate limiter. Limiter Limiter } func (opt *Options) init() { if opt.Addr == \u0026quot;\u0026quot; { opt.Addr = \u0026quot;localhost:6379\u0026quot; } if opt.Network == \u0026quot;\u0026quot; { if strings.HasPrefix(opt.Addr, \u0026quot;/\u0026quot;) { opt.Network = \u0026quot;unix\u0026quot; } else { opt.Network = \u0026quot;tcp\u0026quot; } } if opt.DialTimeout == 0 { opt.DialTimeout = 5 * time.Second } if opt.Dialer == nil { opt.Dialer = func(ctx context.Context, network, addr string) (net.Conn, error) { netDialer := \u0026amp;net.Dialer{ Timeout: opt.DialTimeout, KeepAlive: 5 * time.Minute, } if opt.TLSConfig == nil { return netDialer.DialContext(ctx, network, addr) } return tls.DialWithDialer(netDialer, network, addr, opt.TLSConfig) } } if opt.PoolSize == 0 { opt.PoolSize = 10 * runtime.NumCPU() } switch opt.ReadTimeout { case -1: opt.ReadTimeout = 0 case 0: opt.ReadTimeout = 3 * time.Second } switch opt.WriteTimeout { case -1: opt.WriteTimeout = 0 case 0: opt.WriteTimeout = opt.ReadTimeout } if opt.PoolTimeout == 0 { opt.PoolTimeout = opt.ReadTimeout + time.Second } if opt.IdleTimeout == 0 { opt.IdleTimeout = 5 * time.Minute } if opt.IdleCheckFrequency == 0 { opt.IdleCheckFrequency = time.Minute } if opt.MaxRetries == -1 { opt.MaxRetries = 0 } switch opt.MinRetryBackoff { case -1: opt.MinRetryBackoff = 0 case 0: opt.MinRetryBackoff = 8 * time.Millisecond } switch opt.MaxRetryBackoff { case -1: opt.MaxRetryBackoff = 0 case 0: opt.MaxRetryBackoff = 512 * time.Millisecond } }  åˆ›å»ºè¿æ¥æ±  è¿æ¥æ± çš„é…ç½®æ‰¿æ¥è‡ªclientçš„optionsï¼Œåˆå§‹åŒ–è¿æ¥æ± å¤§å°çš„é…ç½®åæ ¹æ®è¿æ¥æ± çš„å¤§å°åˆ›å»ºå¯¹åº”ä¸ªæ•°çš„è¿æ¥å¡«å……åˆ°connsä»¥åŠidlconnsï¼Œè¿™é‡Œé€šè¿‡ä¸€ä¸ªå¸¦ç¼“å†²çš„queue channelæ¥æ§åˆ¶ç¼“å†²æ± çš„çŠ¶æ€ï¼Œçœå»é€šè¿‡æ•°å€¼æ¯”è¾ƒæ¯æ¬¡éƒ½è¦åŠ é”çš„æŸè€—ã€‚åˆå§‹åŒ–å®Œæˆåé€šè¿‡å¯ä¸€ä¸ªgoruntineæŒ‰æŒ‡å®šçš„é¢‘ç‡å®šæ—¶æ£€æµ‹ç©ºé—²è¿æ¥ä¸­ä¹…æœªä½¿ç”¨ï¼ˆè¶…è¿‡idleTimeoutï¼‰å’Œè¶…è¿‡æœ€å¤§å­˜æ´»æ—¶é—´çš„ï¼ˆçŒœæµ‹æ˜¯ç”±äºè¿æ¥å»ºç«‹è¶…è¿‡ä¸€å®šæ—¶é—´å¯èƒ½å› ä¸ºæŸç§åŸå› å·²ç»æ–­å¼€TCPè¿æ¥è€Œä¸å¯ç”¨ï¼‰ã€‚\nfunc NewConnPool(opt *Options) *ConnPool { p := \u0026amp;ConnPool{ opt: opt, queue: make(chan struct{}, opt.PoolSize), conns: make([]*Conn, 0, opt.PoolSize), idleConns: make([]*Conn, 0, opt.PoolSize), closedCh: make(chan struct{}), } p.connsMu.Lock() p.checkMinIdleConns() p.connsMu.Unlock() if opt.IdleTimeout \u0026gt; 0 \u0026amp;\u0026amp; opt.IdleCheckFrequency \u0026gt; 0 { go p.reaper(opt.IdleCheckFrequency) } return p }  æŒ‡å®šæ‰§è¡Œå‘½ä»¤çš„æ–¹æ³• c.cmdable = c.Process  ä»£ç è·Ÿè¸ªåˆ°æœ€ç»ˆè¿™ä¸ªcmdableæ˜¯ä½äºbaseClient#_processï¼Œå„ç§Redisè¢«å°è£…æˆä¸€ä¸ªcmderç„¶åå†è¿™ä¸ªæ–¹æ³•ä¸­é€šè¿‡è·å–è¿æ¥ï¼Œæœ€åå†™å…¥socketçš„æ–¹å¼æ‰§è¡ŒRediså‘½ä»¤ã€‚\nfunc (c *baseClient) _process(ctx context.Context, cmd Cmder) error { var lastErr error for attempt := 0; attempt \u0026lt;= c.opt.MaxRetries; attempt++ { attempt := attempt var retry bool err := internal.WithSpan(ctx, \u0026quot;process\u0026quot;, func(ctx context.Context) error { if attempt \u0026gt; 0 { if err := internal.Sleep(ctx, c.retryBackoff(attempt)); err != nil { return err } } retryTimeout := true err := c.withConn(ctx, func(ctx context.Context, cn *pool.Conn) error { err := cn.WithWriter(ctx, c.opt.WriteTimeout, func(wr *proto.Writer) error { return writeCmd(wr, cmd) }) if err != nil { return err } err = cn.WithReader(ctx, c.cmdTimeout(cmd), cmd.readReply) if err != nil { retryTimeout = cmd.readTimeout() == nil return err } return nil }) if err == nil { return nil } retry = shouldRetry(err, retryTimeout) return err }) if err == nil || !retry { return err } lastErr = err } return lastErr }  è¿æ¥æ± çš„å®ç° å¦‚ä½•è·å–è¿æ¥ è·å–è¿æ¥æ—¶é€šè¿‡queueè¿™ä¸ªç¼“å†²ä¿¡å·é€šé“æ¥åˆ¤æ–­è¿æ¥æ± æ˜¯å¦å·²ç»ä½¿ç”¨æ»¡ï¼Œåœ¨p.waitTurnè¿™ä¸ªæ–¹æ³•ä¸­é¦–å…ˆå°è¯•å‘queueå‘é€ä¿¡å·ï¼Œå¦‚ä½•queueé˜»å¡è¯´æ˜ç¼“å†²æ± å·²ç»ç”¨æ»¡ï¼Œéœ€è¦åœ¨ä¸€å®šçš„timeoutæ—¶é—´å†…ä¸æ–­é‡è¯•ã€‚è¿™é‡Œçš„è¶…æ—¶timersé‡‡ç”¨äº†æ± åŒ–ï¼Œé¿å…è¿æ¥æ± æŒç»­æ»¡è´Ÿè·æ—¶éœ€è¦æŒç»­åˆ›å»ºtimerå°å¯¹è±¡å¯¼è‡´ä¸æ–­GCã€‚\nvar timers = sync.Pool{ New: func() interface{} { t := time.NewTimer(time.Hour) t.Stop() return t }, } func (p *ConnPool) waitTurn(ctx context.Context) error { select { case \u0026lt;-ctx.Done(): return ctx.Err() default: } select { case p.queue \u0026lt;- struct{}{}: return nil default: } timer := timers.Get().(*time.Timer) timer.Reset(p.opt.PoolTimeout) select { case \u0026lt;-ctx.Done(): if !timer.Stop() { \u0026lt;-timer.C } timers.Put(timer) return ctx.Err() case p.queue \u0026lt;- struct{}{}: if !timer.Stop() { \u0026lt;-timer.C } timers.Put(timer) return nil case \u0026lt;-timer.C: timers.Put(timer) atomic.AddUint32(\u0026amp;p.stats.Timeouts, 1) return ErrPoolTimeout } } // Get returns existed connection from the pool or creates a new one. func (p *ConnPool) Get(ctx context.Context) (*Conn, error) { if p.closed() { return nil, ErrClosed } err := p.waitTurn(ctx) if err != nil { return nil, err } for { p.connsMu.Lock() cn := p.popIdle() p.connsMu.Unlock() if cn == nil { break } if p.isStaleConn(cn) { _ = p.CloseConn(cn) continue } atomic.AddUint32(\u0026amp;p.stats.Hits, 1) return cn, nil } atomic.AddUint32(\u0026amp;p.stats.Misses, 1) newcn, err := p.newConn(ctx, true) if err != nil { p.freeTurn() return nil, err } return newcn, nil }  å¦‚ä½•æ”¾å›è¿æ¥æ±  è¿æ¥è¢«ä½¿ç”¨å®Œæ¯•åè°ƒç”¨pool.Putè¿”å›è¿æ¥æ± ï¼ŒPutæ–¹æ³•ä¸­é¦–å…ˆæ£€æŸ¥è¿æ¥æ˜¯å¦è¿˜æœ‰æ²¡æœ‰è¢«è¯»å–çš„æ•°æ®ï¼Œå¦‚æœæœ‰åˆ™å…³é—­è¿æ¥æ”¾å›BadConnErrorã€‚åˆ¤æ–­æ˜¯å¦ä¸ºè¿æ¥æ± ä¸­çš„è¿æ¥ï¼Œå¦‚æœä¸æ˜¯åˆ™ç›´æ¥å…³é—­ã€‚æœ€åå°†è¿æ¥æ”¾å›idleConnsé˜Ÿåˆ—ï¼Œä»queueé€šé“ç§»é™¤ä¸€ä¸ªå…ƒç´ ã€‚\nfunc (p *ConnPool) Put(cn *Conn) { if cn.rd.Buffered() \u0026gt; 0 { internal.Logger.Printf(context.Background(), \u0026quot;Conn has unread data\u0026quot;) p.Remove(cn, BadConnError{}) return } if !cn.pooled { p.Remove(cn, nil) return } p.connsMu.Lock() p.idleConns = append(p.idleConns, cn) p.idleConnsLen++ p.connsMu.Unlock() p.freeTurn() }  å¦‚ä½•å»ºç«‹è¿æ¥ å»ºç«‹è¿æ¥çš„è¿‡ç¨‹å…¶å®å°±æ˜¯è°ƒç”¨optionsä¸­è¿æ¥Redisçš„ç½‘ç»œæ–¹æ³•ï¼Œè¿”å›connectionå†å°è£…æˆ*Conn, å½“è¿æ¥åˆ›å»ºå¤±è´¥çš„æ¬¡æ•°åˆ°è¾¾è¿æ¥æ± çš„sizeæ—¶è§¦å‘ä¸æ–­é‡è¿ç›´åˆ°æˆåŠŸ\nfunc (p *ConnPool) newConn(ctx context.Context, pooled bool) (*Conn, error) { cn, err := p.dialConn(ctx, pooled) if err != nil { return nil, err } p.connsMu.Lock() p.conns = append(p.conns, cn) if pooled { // If pool is full remove the cn on next Put. if p.poolSize \u0026gt;= p.opt.PoolSize { cn.pooled = false } else { p.poolSize++ } } p.connsMu.Unlock() return cn, nil } func (p *ConnPool) dialConn(ctx context.Context, pooled bool) (*Conn, error) { if p.closed() { return nil, ErrClosed } if atomic.LoadUint32(\u0026amp;p.dialErrorsNum) \u0026gt;= uint32(p.opt.PoolSize) { return nil, p.getLastDialError() } netConn, err := p.opt.Dialer(ctx) if err != nil { p.setLastDialError(err) if atomic.AddUint32(\u0026amp;p.dialErrorsNum, 1) == uint32(p.opt.PoolSize) { go p.tryDial() } return nil, err } internal.NewConnectionsCounter.Add(ctx, 1) cn := NewConn(netConn) cn.pooled = pooled return cn, nil } func (p *ConnPool) tryDial() { for { if p.closed() { return } conn, err := p.opt.Dialer(context.Background()) if err != nil { p.setLastDialError(err) time.Sleep(time.Second) continue } atomic.StoreUint32(\u0026amp;p.dialErrorsNum, 0) _ = conn.Close() return } }  ","date":"2020-11-19","permalink":"/posts/go-redis-source-code-learning/","tags":["Go","redis"],"title":"go-redis/redis æºç å­¦ä¹ "},{"content":"go generate æ˜¯ go 1.4ç‰ˆæœ¬æ–°å¢çš„ä¸€ä¸ªç‰¹æ€§ï¼Œç”¨äºåœ¨ç¼–è¯‘å‰é€šè¿‡å‘½ä»¤è‡ªåŠ¨ç”Ÿæˆä»£ç ï¼Œä¾‹å¦‚å®˜æ–¹æä¾›çš„stringerï¼ˆgolang.org/x/tools/cmd/stringerï¼‰ã€‚è¯¥æ³¨é‡Šåªåœ¨.goæºæ–‡ä»¶ä¸­ç”Ÿæ•ˆï¼Œå¹¶ä¸”éœ€è¦æ˜¾ç¤ºè°ƒç”¨go generateå‘½ä»¤æ‰ä¼šæ‰§è¡Œã€‚åœ¨å®é™…é¡¹ç›®ä¸­ç»å¸¸éœ€è¦å®šä¹‰æ•°æ®è¡¨å®ä½“æ¥å¯¹åº”æ•°æ®åº“ä¸­çš„æŸä¸€å¼ è¡¨ï¼Œæ¯æ¬¡å®šä¹‰å®ä½“éƒ½éœ€è¦é‡å¤æ¯”å¯¹æ•°æ®åº“è¡¨å­—æ®µè´¹æ—¶è´¹åŠ›è¿˜å®¹æ˜“é”™æ¼ï¼Œæ‰€ä»¥èŒç”Ÿç”¨go generateè¿™ä¸ªç‰¹æ€§è§£å†³è¿™ä¸ªé‡å¤å·¥ä½œçš„æƒ³æ³•ã€‚\né¢„æœŸæ•ˆæœ  å®šä¹‰ä¸€ä¸ªç©ºå®ä½“ æ ‡æ³¨ //go:generate entity-helper -target StructName -table TableName å°±å¯ä»¥è‡ªåŠ¨å¡«å……å¯¹åº”å­—æ®µåŠæ³¨é‡Šå¹¶ä¸”æ ¼å¼åŒ–  //go:generate entity-helper -target User -table user type User struct { }  å®ç°æ–¹å¼  é€šè¿‡goæ ‡å‡†åº“çš„go/ast go/parse è§£æpackageçš„è¯­æ³•æ ‘ç»“æ„ï¼Œå®šä½åˆ°ç›®æ ‡ç»“æ„ä½“ æŸ¥è¯¢æ•°æ®åº“è¡¨ç»“æ„æ˜ å°„ç”Ÿæˆgolangä»£ç   è¯­æ³•æ ‘çš„ç±»å‹æ¯”è¾ƒå¤š æœ€å¥½å…ˆé€šè¿‡ast.Print(fset, f)çš„æ–¹å¼å°†æ¯ä¸ªæ–‡ä»¶çš„ç»“æ„æ‰“å°å‡ºæ¥åœ¨æ…¢æ…¢å®šä½\npkgInfo, err = build.ImportDir(\u0026quot;./\u0026quot;, 0) if err != nil { return 0, 0, \u0026quot;\u0026quot;, errors.Wrap(err, \u0026quot;fail to import Dir\u0026quot;) } fset := token.NewFileSet() for _, file := range pkgInfo.GoFiles { f, err := parser.ParseFile(fset, file, nil, 0) if err != nil { log.Fatal(err) } //ast.Print(fset, f) ast.Inspect(f, func(node ast.Node) bool { decl, ok := node.(*ast.GenDecl) if !ok { return true } // ä¸€å±‚å±‚è§£æè¯­æ³•æ ‘ } }  å®Œæ•´ä»£ç   https://github.com/nautilis/goentity-helper  ","date":"2020-11-13","permalink":"/posts/golang-generate-entity/","tags":["Go"],"title":"go generate å®æˆ˜â˜æ•°æ®è¡¨å®ä½“ç”Ÿæˆå™¨"},{"content":"å‰é˜µå­çœ‹äº†å…³äºBç«™å¾®æœåŠ¡åŒ–çš„è§†é¢‘åˆ†äº«ï¼Œå¯¹å…¶ä¸­è®²åˆ°çš„æœåŠ¡å‘ç°ç›¸å…³çš„çŸ¥è¯†å°è±¡æ·±åˆ»ï¼Œåé¢å‘ç°è¿™ä¸ªç»„ä»¶æ˜¯å¼€æºçš„, äºæ˜¯éšæ‰‹cloneä¸‹æ¥å­¦ä¹ ä¸€ä¸‹ã€‚discovery æ˜¯Bç«™ä¸»ç«™ä½¿ç”¨çš„æœåŠ¡æ³¨å†Œ/å‘ç°ç»„ä»¶, å…¶è®¾è®¡å‚è€ƒæœåŠ¡æ³¨å†Œå‘ç°é¢†åŸŸçš„æ ‡æ†Netflix Eurekaå¹¶æ‰©å±•äº†ä¸€äº›ç¤¾åŒºæœŸæœ›çš„åŠŸèƒ½ï¼Œæ˜¯ä¸€å¥—çº¯ç²¹çš„APç³»ç»Ÿã€‚Discoveryå®ç°äº†APç±»å‹çš„æœåŠ¡æ³¨å†Œå‘ç°ï¼Œæ®è¯´å¯ç”¨æ€§æé«˜ï¼Œä¸‹é¢å°±æ¥è§‚æ‘©ä¸€ä¸‹æºç ï¼Œä¸€æ¢ç©¶ç«Ÿã€‚\næ¦‚å†µ æ•´ä¸ªåå­—æœåŠ¡æ˜¯ä¸€ä¸ªä¾èµ–äºdiscoveryçš„HTTPæœåŠ¡å™¨ï¼Œå¯¹å¤–æä¾›äº†æœåŠ¡æ³¨å†Œï¼ŒæœåŠ¡ä¿¡æ¯æ‹‰å–ï¼Œåæ³¨å†Œï¼Œå¿ƒè·³ç­‰æ–¹æ³•ã€‚discoveryå…³è”äº†ä¸€ä¸ªregisterçš„ç»“æ„ï¼ŒregisteråŒ…æ‹¬äº†å‡ ä¸ªéƒ¨åˆ†çš„æ•°æ®ï¼Œæ³¨å†Œåˆ°discoveryçš„å®ä¾‹Appsï¼Œè°ƒåº¦ç›¸å…³é…ç½®schedulerï¼ŒæœåŠ¡å¥åº·æ£€æŸ¥ä¸è‡ªæˆ‘ä¿æŠ¤ç”¨åˆ°çš„ç›¸å…³æŒ‡æ ‡æ•°æ®Guardï¼Œå½“å‰é•¿è½®è¯¢æŸ¥è¯¢è¿æ¥çš„ä¿¡æ¯hostsï¼Œä»¥åŠdiscoveryé›†ç¾¤çš„èŠ‚ç‚¹æ•°æ®Nodesã€‚\nå¯åŠ¨è¿‡ç¨‹ func main() { flag.Parse() if err := conf.Init(); err != nil { log.Error(\u0026quot;conf.Init() error(%v)\u0026quot;, err) panic(err) } log.Init(conf.Conf.Log) dis, cancel := discovery.New(conf.Conf) http.Init(conf.Conf, dis) // init signal c := make(chan os.Signal, 1) signal.Notify(c, syscall.SIGHUP, syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGINT) for { s := \u0026lt;-c log.Info(\u0026quot;discovery get a signal %s\u0026quot;, s.String()) switch s { case syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGINT: cancel() time.Sleep(time.Second) log.Info(\u0026quot;discovery quit !!!\u0026quot;) return case syscall.SIGHUP: default: return } } }  ä»å…¥å£å‡½æ•°å¼€å§‹ï¼Œé¦–å…ˆç”¨paladinè¿™ä¸ªbilibiliè‡ªç ”çš„é…ç½®åŠ è½½å™¨è§£æé…ç½®ï¼Œç„¶ååˆ›å»ºdiscoveryå®ä¾‹ï¼Œä¹‹åæ ¹æ®discoveryå®ä¾‹åˆ›å»ºä¸€ä¸ªHTTPæœåŠ¡å¯¹å¤–æä¾›æœåŠ¡ï¼Œæœ€åå°±æ˜¯å¸¸è§çš„ç›‘å¬ç³»ç»Ÿä¿¡å·åœ¨æœåŠ¡é€€å‡ºçš„æ—¶å€™åšä¸€äº›è‡ªæˆ‘åæ³¨å†Œçš„æ‰«å°¾å·¥ä½œã€‚æˆ‘ä»¬å…·ä½“å…³æ³¨ä¸‹discoveryå®ä¾‹çš„åˆå§‹åŒ–è¿‡ç¨‹ã€‚\ndiscoveryå®ä¾‹åˆå§‹åŒ– func New(c *conf.Config) (d *Discovery, cancel context.CancelFunc) { d = \u0026amp;Discovery{ protected: c.EnableProtect, c: c, client: http.NewClient(c.HTTPClient), registry: registry.NewRegistry(c), } d.nodes.Store(registry.NewNodes(c)) //å­˜å‚¨ discoveryèŠ‚ç‚¹ä¿¡æ¯ d.syncUp() //æ‹‰å–å…¶ä»–èŠ‚ç‚¹ä¸Šçš„æ‰€æœ‰æ³¨å†Œä¿¡æ¯, æ³¨å†Œåˆ°å½“å‰èŠ‚ç‚¹ å¹¿æ’­ cancel = d.regSelf() // æœ¬èŠ‚ç‚¹ä¿¡æ¯æ³¨å†Œä»¥åŠå¿ƒè·³, cancelè¢«è°ƒç”¨åä¼šå»æ‰æ³¨å†Œ go d.nodesproc() // ä¸æ–­æ›´æ–°èŠ‚ç‚¹ä¿¡æ¯ go d.exitProtect() // å¯åŠ¨60såé€€å‡ºä¿æŠ¤æ¨¡å¼ return }   é¦–å…ˆåˆ›å»ºäº†ä¸€ä¸ªhttpå®¢æˆ·ç«¯ï¼Œè¿™ä¸ªä¸»è¦æ˜¯åç»­ç”¨æ¥ä¸å…¶ä»–èŠ‚ç‚¹é€šè®¯ åˆ›å»ºRegistry ä»é…ç½®åŠ è½½å…¶ä»–èŠ‚ç‚¹ä¿¡æ¯ åŒæ­¥å…¶ä»–èŠ‚ç‚¹ä¸Šæ³¨å†Œçš„appçš„ä¿¡æ¯ ç›‘å¬èŠ‚ç‚¹å˜æ›´ä¿¡æ¯ è‡ªæˆ‘æ³¨å†Œ æœ€ååœ¨60såï¼ˆç¡®ä¿discoveryæœåŠ¡ä»¥åŠå¯åŠ¨å¹¶ä¸”ç¨³å®šè¿è¡Œï¼‰é€€å‡ºä¿æŠ¤æ¨¡å¼  åˆ›å»ºRegistry // NewRegistry new register. func NewRegistry(conf *conf.Config) (r *Registry) { r = \u0026amp;Registry{ appm: make(map[string]*model.Apps), conns: make(map[string]*hosts), gd: new(Guard), } r.scheduler = newScheduler(r) r.scheduler.Load() go r.scheduler.Reload() go r.proc() return }   appmç”¨äºå­˜å‚¨æ³¨å†Œä¸Šæ¥çš„æœåŠ¡ä¿¡æ¯ï¼Œappid-env =\u0026gt; Apps, Appsæ˜¯æ ¹æ®zoneåˆ†ç»„çš„ zone =\u0026gt; App, App å­˜äº†ä¸€ä¸ªæ ¹æ®hostname åˆ†ç»„çš„instanceså­—å…¸ã€‚ï¼ˆappid-env =\u0026gt; zone =\u0026gt; hostname =\u0026gt; instanceï¼‰ connså­˜å‚¨å½“å‰è¿æ¥åˆ°è¿™ä¸ªèŠ‚ç‚¹çš„è¯·æ±‚æ•°æ®ï¼Œconnsæ˜¯æ ¹æ®envè·Ÿappidsåˆ†ç»„çš„hostså­—å…¸ï¼ˆenv.appid =\u0026gt; hostsï¼‰ï¼Œhostsæ˜¯æ ¹æ®hostnameåˆ†ç»„çš„connå­—å…¸ã€‚æ¯ä¸ªconnå­˜å‚¨äº†è¯·æ±‚çš„å‚æ•°ä¿¡æ¯ï¼Œä»¥åŠä¸€ä¸ªchannelï¼Œå½“æ³¨å†Œå®ä¾‹ä¿¡æ¯å‘ç”Ÿå˜æ—¶é€šè¿‡é€šè¿‡è¿™ä¸ªchannelå¯¹é•¿è½®è¯¢è¯·æ±‚å‘é€ä¿¡å·è¿”å›æœ€æ–°æ³¨å†Œå®ä¾‹æ•°æ®ã€‚ scheduleræ˜¯æœåŠ¡è°ƒåº¦ç›¸å…³çš„é…ç½®ï¼Œåº”è¯¥æ˜¯è®¾ç½®æ¯ä¸ªæœåŠ¡çš„æƒé‡ä¿¡æ¯ä¹‹ç±»çš„ï¼Œæ²¡ç»†çœ‹ã€‚ gdå­˜å‚¨çš„æ˜¯ä¸€äº›æœåŠ¡å¿ƒè·³ç»Ÿè®¡ç›¸å…³çš„æ•°æ®ï¼Œåœ¨ä¸‹é¢çš„proc()æ–¹æ³•ä¸­ä¼šæ¯éš”ä¸€åˆ†é’Ÿå°±ç»Ÿè®¡æ›´æ–°ä¸€æ¬¡å‰ä¸€åˆ†é’Ÿæ”¶åˆ°çš„å¿ƒè·³æ•°ï¼Œå¹¶ä¸”å¼€å¯åˆ†æ‰¹é€æ¬¡å‰”é™¤ä¸€äº›ä¸å¯ç”¨çš„æœåŠ¡ï¼ˆéä¿æŠ¤æ¨¡å¼ä¸‹90sæ²¡æœ‰å¿ƒè·³çš„æœåŠ¡ï¼‰ï¼Œå€¼å¾—æ³¨æ„çš„æ˜¯ä¸ç®¡ç¬¦åˆå‰”é™¤æ¡ä»¶çš„æœåŠ¡æ•°æ®æœ‰å¤šå°‘ï¼Œæ¯æ¬¡æœ€å¤šåªèƒ½éšæœºå‰”é™¤æœåŠ¡æ€»æ•°çš„25%çš„ä¸å¯ç”¨æœåŠ¡ã€‚  func (r *Registry) evict() { protect := r.gd.ok() // We collect first all expired items, to evict them in random order. For large eviction sets, // if we do not that, we might wipe out whole apps before self preservation kicks in. By randomizing it, // the impact should be evenly distributed across all applications. var eis []*model.Instance var registrySize int // all projects ass := r.allapp() for _, as := range ass { for _, a := range as.App(\u0026quot;\u0026quot;) { registrySize += a.Len() is := a.Instances() for _, i := range is { delta := time.Now().UnixNano() - i.RenewTimestamp if (!protect \u0026amp;\u0026amp; delta \u0026gt; _evictThreshold) || delta \u0026gt; _evictCeiling { eis = append(eis, i) } } } } // To compensate for GC pauses or drifting local time, we need to use current registry size as a base for // triggering self-preservation. Without that we would wipe out full registry. eCnt := len(eis) registrySizeThreshold := int(float64(registrySize) * _percentThreshold) evictionLimit := registrySize - registrySizeThreshold if eCnt \u0026gt; evictionLimit { eCnt = evictionLimit } if eCnt == 0 { return } for i := 0; i \u0026lt; eCnt; i++ { // Pick a random item (Knuth shuffle algorithm) next := i + rand.Intn(len(eis)-i) eis[i], eis[next] = eis[next], eis[i] ei := eis[i] r.cancel(ei.Zone, ei.Env, ei.AppID, ei.Hostname, time.Now().UnixNano()) } }  æ¯éš”15åˆ†é’Ÿæ›´æ–°ä¸€æ¬¡æœŸæœ›å¿ƒè·³æ•°ï¼ŒæœŸæœ›å¿ƒè·³æ•°ä¸ºæ³¨å†Œåˆ°å½“å‰èŠ‚ç‚¹çš„å®ä¾‹æ€»æ•°*2 * 0.82ï¼Œå½“æ¯åˆ†é’Ÿæ¥æ”¶åˆ°çš„å¿ƒè·³æ€»æ•°å°äºè¿™ä¸ªæœŸæœ›å€¼çš„æ—¶å€™æœåŠ¡è¿›å…¥ä¿æŠ¤æ¨¡å¼ä¸è¿›è¡Œéšæœºå‰”é™¤ä¸å¯ç”¨èŠ‚ç‚¹çš„æ“ä½œã€‚\nåŠ è½½å…¶ä»–èŠ‚ç‚¹ä¿¡æ¯ discoveryæ”¯æŒé›†ç¾¤éƒ¨ç½²ï¼Œé€šè¿‡é…ç½®åŠ è½½å…¶ä»–èŠ‚ç‚¹çš„ä¿¡æ¯ä»¥åŠå…¶ä»–æ•°æ®ä¸­å¿ƒçš„èŠ‚ç‚¹çš„ä¿¡æ¯ï¼Œç”¨äºåç»­äºå…¶ä»–èŠ‚ç‚¹é€šè®¯ï¼Œ Nodesæœ€ç»ˆé€šè¿‡atom.Valueå­˜èµ·æ¥\n// NewNodes new nodes and return. func NewNodes(c *conf.Config) *Nodes { nodes := make([]*Node, 0, len(c.Nodes)) for _, addr := range c.Nodes { // å½“å‰æ•°æ®ä¸­å¿ƒçš„èŠ‚ç‚¹ä¿¡æ¯ n := newNode(c, addr) n.zone = c.Env.Zone n.pRegisterURL = fmt.Sprintf(\u0026quot;http://%s%s\u0026quot;, c.HTTPServer.Addr, _registerURL) // æ³¨å†Œçš„httpè·¯å¾„ nodes = append(nodes, n) } zones := make(map[string][]*Node) for name, addrs := range c.Zones { // å…¶ä»–æ•°æ®ä¸­å¿ƒçš„èŠ‚ç‚¹ä¿¡æ¯ var znodes []*Node for _, addr := range addrs { n := newNode(c, addr) n.otherZone = true n.zone = name n.pRegisterURL = fmt.Sprintf(\u0026quot;http://%s%s\u0026quot;, c.HTTPServer.Addr, _registerURL) znodes = append(znodes, n) } zones[name] = znodes } return \u0026amp;Nodes{ nodes: nodes, zones: zones, selfAddr: c.HTTPServer.Addr, // å½“å‰èŠ‚ç‚¹åœ°å€ }  syncUpåŒæ­¥å…¶ä»–èŠ‚ç‚¹çš„æ³¨å†Œå®ä¾‹ ä¾¿åˆ©å…¶ä»–èŠ‚ç‚¹ï¼Œé€ä¸ªå…¨é‡æ‹‰å–æ³¨å†Œåœ¨è¿™äº›èŠ‚ç‚¹ä¸Šçš„æœåŠ¡ï¼Œç„¶åå°†è¿™äº›æœåŠ¡çš„æ³¨å†Œä¿¡æ¯æ³¨å†Œåˆ°å½“å‰èŠ‚ç‚¹ä¸Šï¼Œä¹Ÿå°±æ˜¯å­˜å‚¨åˆ°registryçš„appmç»“æ„ä¸­ï¼ŒåŒæ—¶å¯¹å…³æ³¨è¿™ä¸ªappidçš„é•¿è½®è¯¢è¿›è¡Œé€šçŸ¥ï¼ˆè¿™ä¸ªæ³¨å†Œ\u0026ndash;é•¿è½®è¯¢æ‹‰å–çš„äº¤äº’è¿‡ç¨‹åç»­åœ¨åšå…·ä½“è§£æï¼‰\nregSelfè‡ªæ³¨å†Œ å°†æœ¬èŠ‚ç‚¹ä½œä¸ºå®ä¾‹æœåŠ¡æ³¨å†Œåˆ°discoveryé›†ç¾¤ï¼Œæ³¨å†Œåˆ°æœ¬èŠ‚ç‚¹ åŒæ—¶æ³¨å†Œåˆ°æ‰€æœ‰å…¶ä»–é›†ç¾¤ä¸­çš„èŠ‚ç‚¹ã€‚\nfunc (d *Discovery) Register(c context.Context, ins *model.Instance, latestTimestamp int64, replication bool, fromzone bool) { _ = d.registry.Register(ins, latestTimestamp) if !replication { //ä¸‹é¢çš„æ–¹æ³•å¯¹æ‰€æœ‰nodeséƒ½æ³¨å†Œæœ¬èŠ‚ç‚¹ _ = d.nodes.Load().(*registry.Nodes).Replicate(c, model.Register, ins, fromzone) } }  æ³¨å†Œå®Œåæ²¡30så¯¹é›†ç¾¤ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹å‘é€å¿ƒè·³ï¼Œæ£€æµ‹åˆ°å–æ¶ˆä¿¡å·æ—¶è¿›è¡Œåæ³¨å†Œ\ngo func() { ticker := time.NewTicker(30 * time.Second) defer ticker.Stop() for { select { case \u0026lt;-ticker.C: arg := \u0026amp;model.ArgRenew{ AppID: ins.AppID, Zone: d.c.Env.Zone, Env: d.c.Env.DeployEnv, Hostname: d.c.Env.Host, } if _, err := d.Renew(ctx, arg); err != nil \u0026amp;\u0026amp; err == ecode.NothingFound { d.Register(ctx, ins, now, false, false) } case \u0026lt;-ctx.Done(): arg := \u0026amp;model.ArgCancel{ AppID: model.AppID, Zone: d.c.Env.Zone, Env: d.c.Env.DeployEnv, Hostname: d.c.Env.Host, } if err := d.Cancel(context.Background(), arg); err != nil { log.Error(\u0026quot;d.Cancel(%+v) error(%v)\u0026quot;, arg, err) } return } } }()  nodesprocç›‘å¬èŠ‚ç‚¹å˜åŒ– å¦‚ä¸Šé¢çš„æµç¨‹ï¼Œé›†ç¾¤ä¸­æ–°å¢æŸä¸ªèŠ‚ç‚¹è¿™ä¸ªèŠ‚ç‚¹å°±ä¼šå°†è‡ªå·±æ³¨å†Œåˆ°è¿™ä¸ªé›†ç¾¤ä¸­å»ï¼Œæ‰€ä»¥èŠ‚ç‚¹å¯åŠ¨å®Œæˆåé™¤äº†é…ç½®æ–‡ä»¶ä¸­çš„èŠ‚ç‚¹ï¼Œé›†ç¾¤ä¸­è¿˜å¯èƒ½åŠ¨æ€æ–°å¢äº†èŠ‚ç‚¹ï¼Œnodesprocå°±æ˜¯ç›‘å¬èŠ‚ç‚¹å˜åŒ–çš„æ–¹æ³•é€šè¿‡pollsç›‘å¬appid=infra.discoveryçš„æœåŠ¡å˜æ›´ï¼Œæ¯æ¬¡æ£€æµ‹åˆ°å˜æ›´åˆ™æ›´æ–°Nodesè¿™ä¸ªatom.Value\nfunc (d *Discovery) nodesproc() { var ( lastTs int64 ) for { arg := \u0026amp;model.ArgPolls{ AppID: []string{model.AppID}, Env: d.c.Env.DeployEnv, Hostname: d.c.Env.Host, LatestTimestamp: []int64{lastTs}, } ch, _, _, err := d.registry.Polls(arg) if err != nil \u0026amp;\u0026amp; err != ecode.NotModified { log.Error(\u0026quot;d.registry(%v) error(%v)\u0026quot;, arg, err) time.Sleep(time.Second) continue } apps := \u0026lt;-ch ins, ok := apps[model.AppID] if !ok || ins == nil { return } var ( nodes []string zones = make(map[string][]string) ) for _, ins := range ins.Instances { for _, in := range ins { for _, addr := range in.Addrs { u, err := url.Parse(addr) if err == nil \u0026amp;\u0026amp; u.Scheme == \u0026quot;http\u0026quot; { if in.Zone == d.c.Env.Zone { nodes = append(nodes, u.Host) } else { zones[in.Zone] = append(zones[in.Zone], u.Host) } } } } } lastTs = ins.LatestTimestamp c := new(conf.Config) *c = *d.c c.Nodes = nodes c.Zones = zones ns := registry.NewNodes(c) ns.UP() d.nodes.Store(ns) log.Info(\u0026quot;discovery changed nodes:%v zones:%v\u0026quot;, nodes, zones) } }  æ³¨å†Œ æ¯ä¸ªéœ€è¦æ³¨å†Œçš„æœåŠ¡é€šè¿‡è°ƒdiscoveryçš„/registeræ¥å£å°†è‡ªèº«æ³¨å†Œä¸Šæ¥ï¼Œæ³¨å†Œå‚æ•°å¦‚ä¸‹ã€‚\ntype ArgRegister struct { Region string `form:\u0026quot;region\u0026quot;` Zone string `form:\u0026quot;zone\u0026quot; validate:\u0026quot;required\u0026quot;` Env string `form:\u0026quot;env\u0026quot; validate:\u0026quot;required\u0026quot;` AppID string `form:\u0026quot;appid\u0026quot; validate:\u0026quot;required\u0026quot;` Hostname string `form:\u0026quot;hostname\u0026quot; validate:\u0026quot;required\u0026quot;` Status uint32 `form:\u0026quot;status\u0026quot; validate:\u0026quot;required\u0026quot;` Addrs []string `form:\u0026quot;addrs\u0026quot; validate:\u0026quot;gt=0\u0026quot;` Version string `form:\u0026quot;version\u0026quot;` Metadata string `form:\u0026quot;metadata\u0026quot;` Replication bool `form:\u0026quot;replication\u0026quot;` // æ˜¯å¦å±äºdiscoveryèŠ‚ç‚¹é—´å¤åˆ¶çš„è¯·æ±‚ LatestTimestamp int64 `form:\u0026quot;latest_timestamp\u0026quot;` DirtyTimestamp int64 `form:\u0026quot;dirty_timestamp\u0026quot;` FromZone bool `form:\u0026quot;from_zone\u0026quot;` }  è§£æå®Œè¿™äº›å‚æ•°ç»„è£…æˆä¸€ä¸ªinstanceå®ä¾‹æœ€åå­˜å‚¨åˆ°registry#appmï¼ŒåŒæ—¶å‘discoveryé›†ç¾¤çš„å…¶ä»–èŠ‚ç‚¹æ³¨å†Œè¿™ä¸ªinstance\n// Register a new instance. func (d *Discovery) Register(c context.Context, ins *model.Instance, latestTimestamp int64, replication bool, fromzone bool) { _ = d.registry.Register(ins, latestTimestamp) if !replication { // Replicate ä¼šåŒæ­¥é›†ç¾¤çš„å…¶ä»–èŠ‚ç‚¹ _ = d.nodes.Load().(*registry.Nodes).Replicate(c, model.Register, ins, fromzone) } }  æ¯å½“æœ‰æ–°å®ä¾‹åŠ å…¥è¿›æ¥ï¼Œä¼šæ›´æ–°Registryçš„å¿ƒè·³æœŸæœ› r.gd.incrExp() , åŒæ—¶å¯¹æ­£åœ¨è¿›è¡Œé•¿è½®è¯¢è®¢é˜…è¿™ä¸ªå®ä¾‹çš„è¿æ¥è¿›è¡Œå¹¿æ’­ã€‚\n// Register a new instance. func (r *Registry) Register(ins *model.Instance, latestTime int64) (err error) { a := r.newApp(ins) i, ok := a.NewInstance(ins, latestTime) if ok { r.gd.incrExp() // å¢åŠ å¿ƒè·³æœŸæœ›å€¼ } // NOTE: make sure free poll before update appid latest timestamp. r.broadcast(i.Env, i.AppID) // å¯¹é•¿è½®è¯¢è¿›è¡Œå¹¿æ’­è¿”å›ç»“æœ return }  å¹¿æ’­å°±æ˜¯Fetchè¿™ä¸ªappidçš„æ‰€æœ‰å®ä¾‹ä¿¡æ¯å‡ºæ¥ï¼Œæ ¹æ®æ¯ä¸ªé•¿è½®è¯¢çš„æ¡ä»¶è¿›è¡Œè¿‡æ»¤ï¼Œæœ€åé€šè¿‡channelå‘é€è¿‡æ»¤å‡ºæ¥çš„ç»“æœé›†ï¼Œé•¿è½®è¯¢é‚£è¾¹æ¥æ”¶åˆ°channelä¿¡å·å³è¿”å›ç»“æœã€‚\n// broadcast on poll by chan. // NOTE: make sure free poll before update appid latest timestamp. func (r *Registry) broadcast(env, appid string) { key := pollKey(env, appid) r.cLock.Lock() conns, ok := r.conns[key] if !ok { r.cLock.Unlock() return } delete(r.conns, key) r.cLock.Unlock() conns.hclock.RLock() for _, conn := range conns.hosts { ii, err := r.Fetch(conn.arg.Zone, env, appid, 0, model.InstanceStatusUP) // TODO(felix): latesttime!=0 increase if err != nil { // may be not found ,just continue until next poll return err. log.Error(\u0026quot;get appid:%s env:%s zone:%s err:%v\u0026quot;, appid, env, conn.arg.Zone, err) continue } for i := 0; i \u0026lt; conn.count; i++ { select { case conn.ch \u0026lt;- map[string]*model.InstanceInfo{appid: ii}: // NOTE: if chan is full, means no poller. log.Info(\u0026quot;broadcast to(%s) success(%d)\u0026quot;, conn.arg.Hostname, i+1) case \u0026lt;-time.After(time.Millisecond * 500): log.Info(\u0026quot;broadcast to(%s) failed(%d) maybe chan full\u0026quot;, conn.arg.Hostname, i+1) } } } conns.hclock.RUnlock() }  æ‹‰å– æ‹‰å–é€šè¿‡fetchè¿‡æ»¤å–argPollsä¸­æŒ‡å®šçš„appå®ä¾‹ï¼ŒFetchæ–¹æ³•é€šè¿‡å¯¹æ¯”appmä¸­å­˜å‚¨çš„å®ä¾‹çš„latestTimestamp, å¦‚æœlatestTimestamp \u0026lt; å­˜å‚¨çš„å®ä¾‹çš„lastTimestamp è¯´æ˜æ³¨å†Œä¸­çš„å®ä¾‹å˜æ›´è¿˜æ²¡æœ‰è¢«æ‹‰å–åˆ°ï¼Œç›´æ¥è¿”å›è¿™ä¸ªå®ä¾‹çš„ä¿¡æ¯ã€‚å¦‚æœlatestTimestamp \u0026gt;= å­˜å‚¨å®ä¾‹çš„lastTimestamp, è¯´æ˜ä¹‹å‰æ‹‰å–åˆ°çš„å·²ç»æ˜¯æœ€æ–°çš„å®ä¾‹æ³¨å†Œä¿¡æ¯ï¼Œè¿™ä¸ªæ—¶å€™å›é˜»å¡ç­‰å¾…channelä¿¡å·ã€‚\n// Polls hangs request and then write instances when that has changes, or return NotModified. func (r *Registry) Polls(arg *model.ArgPolls) (ch chan map[string]*model.InstanceInfo, new bool, miss []string, err error) { var ( ins = make(map[string]*model.InstanceInfo, len(arg.AppID)) ) if len(arg.AppID) != len(arg.LatestTimestamp) { arg.LatestTimestamp = make([]int64, len(arg.AppID)) } for i := range arg.AppID { in, err := r.Fetch(arg.Zone, arg.Env, arg.AppID[i], arg.LatestTimestamp[i], model.InstanceStatusUP) if err == ecode.NothingFound { miss = append(miss, arg.AppID[i]) log.Error(\u0026quot;Polls zone(%s) env(%s) appid(%s) error(%v)\u0026quot;, arg.Zone, arg.Env, arg.AppID[i], err) continue } if err == nil { ins[arg.AppID[i]] = in new = true } } if new { ch = make(chan map[string]*model.InstanceInfo, 1) ch \u0026lt;- ins return } for i := range arg.AppID { k := pollKey(arg.Env, arg.AppID[i]) r.cLock.Lock() if _, ok := r.conns[k]; !ok { r.conns[k] = \u0026amp;hosts{hosts: make(map[string]*conn, 1)} } hosts := r.conns[k] r.cLock.Unlock() hosts.hclock.Lock() connection, ok := hosts.hosts[arg.Hostname] if !ok { if ch == nil { ch = make(chan map[string]*model.InstanceInfo, 5) // NOTE: there maybe have more than one connection on the same hostname!!! } connection = newConn(ch, arg.LatestTimestamp[i], arg) log.Info(\u0026quot;Polls from(%s) new connection(%d)\u0026quot;, arg.Hostname, connection.count) } else { connection.count++ // NOTE: there maybe have more than one connection on the same hostname!!! if ch == nil { ch = connection.ch } log.Info(\u0026quot;Polls from(%s) reuse connection(%d)\u0026quot;, arg.Hostname, connection.count) } hosts.hosts[arg.Hostname] = connection hosts.hclock.Unlock() } return }  å¿ƒè·³ æ¯ä¸ªæ³¨å†Œåˆ°discoveryçš„æœåŠ¡éœ€è¦æ¯éš”30så°±å‘discoveryå‘é€ä¸€æ¬¡å¿ƒè·³ï¼Œdiscoveryæ›´æ–°appçš„renewæ—¶é—´æˆ³ï¼ŒåŒæ—¶æ›´æ–°æ”¶åˆ°å½“å‰åˆ†é’Ÿæ”¶åˆ°çš„å¿ƒè·³æ•° atomic.AddInt64(\u0026amp;g.facInMin, 1) ã€‚åŒæ—¶æ¯ä¸ªèŠ‚ç‚¹æ¥æ”¶åˆ°çš„å¿ƒè·³ä¹Ÿä¼šå¤åˆ¶ç»™å…¶ä»–èŠ‚ç‚¹ã€‚\n// Renew marks the given instance of the given app name as renewed, and also marks whether it originated from replication. func (d *Discovery) Renew(c context.Context, arg *model.ArgRenew) (i *model.Instance, err error) { i, ok := d.registry.Renew(arg) if !ok { err = ecode.NothingFound log.Error(\u0026quot;renew appid(%s) hostname(%s) zone(%s) env(%s) error\u0026quot;, arg.AppID, arg.Hostname, arg.Zone, arg.Env) return } if !arg.Replication { _ = d.nodes.Load().(*registry.Nodes).Replicate(c, model.Renew, i, arg.Zone != d.c.Env.Zone) return } if arg.DirtyTimestamp \u0026gt; i.DirtyTimestamp { err = ecode.NothingFound } else if arg.DirtyTimestamp \u0026lt; i.DirtyTimestamp { err = ecode.Conflict } return }  ","date":"2020-08-29","permalink":"/posts/learn-discovery-source-code/","tags":["Go","Microservices"],"title":"bilibili/discovery æºç è§£æ"},{"content":"åœ¨å¤§å‹ä¸šåŠ¡ç³»ç»Ÿä¸­æˆ‘ä»¬å¸¸å¸¸éœ€è¦å¯¹æ•°æ®åº“è¿›è¡Œåˆ†åº“åˆ†è¡¨å¤„ç†ï¼Œæ­¤æ—¶æ•°æ®çš„å”¯ä¸€æ ‡è¯†æ— æ³•å†é€šè¿‡ä¾èµ–æ•°æ®åº“å”¯ä¸€é”®çš„æ–¹å¼å®ç°ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦ä¸€ä¸ªidæœåŠ¡è´Ÿè´£åˆ†é…å”¯ä¸€idã€‚åˆ†å¸ƒå¼idç”Ÿæˆå™¨åœ¨å¦‚ä»Šå·²ç»æ˜¯å†å¯»å¸¸ä¸è¿‡çš„éœ€æ±‚ï¼Œä¸šå†…æœ‰è®¸å¤šæˆç†Ÿçš„æ–¹æ¡ˆï¼Œæœ€å‡ºåçš„æœ‰Twitterçš„snowflakeç®—æ³•ï¼Œå›½å†…å¾ˆå¤šå¤§å‚ä¹Ÿæœ‰è‡ªå·±çš„å®ç°æ–¹æ¡ˆä¾‹å¦‚ç¾å›¢çš„Left,ç™¾åº¦çš„uid-generatorã€‚ä»Šå¤©æˆ‘ä»¬é€šè¿‡Redisæ¥å®ç°ä¸€ä¸ªåˆ†å¸ƒå¼IDç”Ÿæˆå™¨ï¼Œè¦æ±‚æ¯”è¾ƒç®€å•ï¼Œé™¤äº†idè¦å”¯ä¸€,æ”¯æŒåˆ†å¸ƒå¼ï¼Œè¿˜è¦ä¿è¯å®šé•¿è·Ÿæ— åºã€‚\nå®ç°æ–¹æ³•  å¤šå°æœºå™¨IDä¿æŒå”¯ä¸€ï¼šidé€šè¿‡æ•°å­—æ˜ å°„åˆ°35ä¸ªæ•°å­—å­—æ¯ç»„æˆ(1-9,a-z, 0ä½œä¸ºè¡¥ä½), æ•´ä¸ªidåˆ†ä¸ºä¸¤æ®µï¼Œå‰æ®µ4ä½å­—ç¬¦ç”±å½“å‰æ—¶é—´è·ŸæœåŠ¡çš„èµ·å§‹æ—¶é—´åšå·®ä»¥åŠæœºå™¨ç¼–å·å†³å®šï¼Œåæ®µ5ä½å­—ç¬¦åˆ™é€šè¿‡éšæœºç”Ÿæˆæ•°å­—å†é€šè¿‡Redisçš„bitmapæ’é‡ã€‚æ’é‡çš„keyä½¿ç”¨idçš„å‰æ®µæ ‡è¯†ï¼Œredis bitmapå¯ä»¥æœ€å¤šå¯ä»¥æ ‡è®°2^32-1ï¼Œåæ®µä½æ•°ä¸º5å…±35^5=52521875ä¸ªéšæœºæ•°,å‡å¦‚å¹¶å‘é«˜åˆ°10000tpsä¸€ä¸ªå°æ—¶å†…ä¹Ÿä¸ä¼šè¶…è¿‡52521875äº†ã€‚ å•ä¸ªè¿›ç¨‹ä¸­IDçš„å­˜å–ï¼šé€šè¿‡channelå­˜å‚¨ç”Ÿæˆçš„id, å½“channelæ»¡æ—¶ä¼‘çœ ï¼Œchannelè¢«æ¶ˆè´¹æœ‰å‰©ä½™ç©ºé—´æ—¶è¡¥å……idã€‚  package main import ( \u0026quot;bytes\u0026quot; \u0026quot;context\u0026quot; \u0026quot;github.com/go-redis/redis\u0026quot; \u0026quot;log\u0026quot; \u0026quot;math/rand\u0026quot; \u0026quot;os\u0026quot; \u0026quot;strconv\u0026quot; \u0026quot;sync\u0026quot; \u0026quot;time\u0026quot; ) var redisClient *redis.Client type IdGenerate struct { base35code []byte startTime int64 machineCode int //æœåŠ¡å™¨ç¼–ç (é€šè¿‡hostnameåç¼€è·å–ï¼‰ redisClient *redis.Client random *rand.Rand idChannel chan string //å­˜å‚¨ç”Ÿæˆidçš„ç®¡é“ } func NewIdGenerate() *IdGenerate { inst := \u0026amp;IdGenerate{ startTime: 1596782020, random: rand.New(rand.NewSource(time.Now().Unix())), idChannel: make(chan string, 10000), } hostName, _ := os.Hostname() machineId, _ := strconv.Atoi(hostName[len(hostName)-2:]) inst.machineCode = machineId base35Code := \u0026quot;123456789qwertyuioplkjhgfdsazxcvbnm\u0026quot; inst.base35code = []byte(base35Code) redisClient := redis.NewClient(\u0026amp;redis.Options{ Addr: \u0026quot;127.0.0.1:6379\u0026quot;, }) inst.redisClient = redisClient return inst } //å°†æ•°å­—æ˜ å°„æˆå­—æ¯æ•°å­—ç»„åˆå­—ç¬¦ä¸² func (this *IdGenerate) getBase35Code(num int64) string { codeLen := int64(len(this.base35code)) buf := bytes.Buffer{} for { c := this.base35code[num%codeLen] buf.WriteByte(c) num = num / codeLen if num \u0026lt;= 0 { break } } return buf.String() } //å½“å‰æ—¶é—´ä¸æœåŠ¡èµ·å§‹æ—¶é—´åšå·®æ¥ç¡®å®šä¸€ä¸ªæ’é‡key func (this *IdGenerate) getDistinctKey() string { key := this.getBase35Code((time.Now().Unix()-this.startTime)/3600*100 + int64(this.machineCode)) //*100 é¢„ç•™ä¸¤ä½ç»™æœºå™¨id pack := bytes.Buffer{} if len(key) \u0026lt; 4 { //ä¸è¶³å››ä½é€šè¿‡0è¡¥é½ for i := len(key); i \u0026lt; 4; i++ { pack.WriteByte('0') } } pack.WriteString(key) return pack.String() } //é€šè¿‡bitmapè¿‡æ»¤ä¸æ–­çš„å°è¯•ç”Ÿæˆæ–°id func (this *IdGenerate) genId() string { distinctKey := this.getDistinctKey() c, err := this.redisClient.BitCount(context.Background(), distinctKey, nil).Result() if err != nil { log.Print(err.Error()) } if c == 0 || c%100 == 0 { //è®¾ç½®æ–°key 2å°æ—¶åè¿‡æœŸï¼Œè¿™é‡Œæ€•ä¸€æ¬¡è®¾ç½®å¯èƒ½å¤±è´¥æ•…æ²¡åœ¨bitmap æ¯æ ‡è®°100ä¸ªå°±é‡æ–°è®¾ç½®ä¸€æ¬¡è¿‡æœŸ this.redisClient.Expire(context.Background(), distinctKey, 2*time.Hour) } var id int for { id = this.random.Intn(35) + 1 for i := 0; i \u0026lt; 4; i++ { r := this.random.Intn(35) + 1 id = id * r } val, err := this.redisClient.GetBit(context.Background(), distinctKey, int64(id)).Result() if err != nil { log.Print(\u0026quot;access redis error: \u0026quot; + err.Error()) } if val == 0 { _, err := this.redisClient.SetBit(context.Background(), distinctKey, int64(id), 1).Result() if err != nil { log.Println(err.Error()) continue } break } } randomPart := this.getBase35Code(int64(id)) b := bytes.Buffer{} b.WriteString(distinctKey) b.WriteString(randomPart) if len(randomPart) \u0026lt; 5 { for i := len(randomPart); i \u0026lt; 5; i++ { b.WriteByte('0') } } return b.String() } //å¾ªç¯ä¸æ–­ç”Ÿæˆidçš„æ–¹æ³• func (this *IdGenerate) provideId() { useOld := false var id string for { if !useOld { id = this.genId() } select { case this.idChannel \u0026lt;- id: log.Println(\u0026quot;add id:\u0026quot;, id) useOld = false default: useOld = true time.Sleep(2 * time.Second) } } } //è·å–id func (this *IdGenerate) ConsumeId(size int) (res []string) { //æ€»çš„è¶…æ—¶æ—¶é—´è®¾ç½®ä¸º100ms eachTimeOut := time.Duration(100/size) * time.Millisecond res = make([]string, size) for i := 0; i \u0026lt; size; i++ { select { case id := \u0026lt;-this.idChannel: res = append(res, id) case \u0026lt;-time.After(eachTimeOut): log.Println(\u0026quot;access id time\u0026quot;) } } return res } func main() { generator := NewIdGenerate() wg := sync.WaitGroup{} wg.Add(2) go func() { generator.provideId() wg.Done() }() for i := 0; i \u0026lt; 10; i++ { go func() { for { ids := generator.ConsumeId(3) log.Println(\u0026quot;consume ids:\u0026quot;, ids) time.Sleep(1 * time.Second) } }() } wg.Wait() }  ","date":"2020-08-15","permalink":"/posts/gen-unique-by-redis/","tags":["redis","Go"],"title":"å¾’æ‰‹æ’¸ä¸€ä¸ªåˆ†å¸ƒå¼idç”Ÿæˆå™¨"},{"content":"ä½œä¸ºä¸€ä¸ªæœåŠ¡ç«¯å¼€å‘äººå‘˜ï¼Œç›¸ä¿¡å¤§å®¶éƒ½æœ‰åŠå¤œè¢«çªç„¶çš„å‘Šè­¦æƒŠé†’çš„ç»å†ï¼Œä¹Ÿä¼šæœ‰é¢ä¸´å‘ç”Ÿé—®é¢˜æ‰‹å¿™è„šä¹±æ— ä»ä¸‹æ‰‹çš„æ—¶æœŸï¼Œè¿™ç¯‡æ–‡ç« å›é¡¾äº†è¿‘æœŸæˆ‘æ’æŸ¥ä¸€ä¸ªçº¿ä¸Šæ€§èƒ½é—®é¢˜çš„è¿‡ç¨‹ã€‚\nèƒŒæ™¯ æˆ‘ä¸»è¦è´Ÿè´£çš„ä¸€ä¸ªçº¿ä¸ŠæœåŠ¡åœ¨å¤œæ·±äººé™çš„æŸå¤©è°ƒç”¨æ–¹çªç„¶å‘ŠæœåŠ¡è¶…æ—¶,ä»ä¸Šå›¾å¯ä»¥çœ‹åˆ°é«˜åˆ†æœŸï¼ˆ23ç‚¹åˆ°å‡Œæ™¨2ç‚¹ï¼‰å“åº”æ—¶é—´ä¸¥é‡çš„å·²ç»è¶…è¿‡100msã€‚è¿™æ˜¯ä¸€ä¸ªè¾ƒä¸ºåº•å±‚çš„æœåŠ¡ï¼Œä¸»è¦ä¸ºç”¨æˆ·feedæµæä¾›æ‰¹é‡ç”¨æˆ·å±æ€§æŸ¥è¯¢è·Ÿç”¨æˆ·å…³ç³»æŸ¥è¯¢(è·å–feedæµå†…å®¹ä½œè€…å±æ€§ä»¥åŠå½“å‰ç”¨æˆ·æ˜¯å¦å…³æ³¨è¿™äº›ä½œè€…ï¼‰ã€‚ä¸¤ç§æ•°æ®çš„è·å–é€šè¿‡å†…éƒ¨è°ƒç”¨å¦ä¸€ä¸ªåº•å±‚æœåŠ¡å®ç°ï¼Œå¯¹äºç”¨æˆ·å±æ€§ï¼ŒæœåŠ¡ç«¯å…ˆé€šè¿‡mgetè·å–ç¼“å­˜ä¸­çš„æ•°æ®ï¼Œç¼“å­˜ä¸å‘½ä¸­çš„æƒ…å†µä¸‹å¹¶å‘æŸ¥è¯¢æ•°æ®åº“å†æ±‡æ€»è¿”å›ï¼›ç”¨æˆ·å…³ç³»ï¼Œä¹Ÿæ˜¯å…ˆæŸ¥è¯¢ç¼“å­˜å†é€šè¿‡pipelineæŸ¥è¯¢æŒä¹…æ¢ç¼“å­˜ã€‚æœºå™¨éƒ¨ç½²äº†9å°ï¼Œå…¶ä¸­1å°4æ ¸ï¼Œå…¶ä»–éƒ½æ˜¯2æ ¸ã€‚\nåˆæ­¥æ’æŸ¥  çº¿ä¸Šæ— æ–°å¢ä»£ç ï¼Œè¿›ç¨‹ä¹Ÿæ˜¯å‡ å¤©å‰çš„ï¼Œæ’é™¤æ–°ä»£ç é—®é¢˜ã€‚ pvçªç„¶å¢é•¿äº†ç»20%, æŸ¥çœ‹æœºå™¨è´Ÿè½½å‘ç°cpu,å†…å­˜ï¼Œloadéƒ½å¾ˆæ­£å¸¸ï¼Œä¾èµ–çš„Redisè·ŸRDSä¹Ÿæ²¡æœ‰è¶…æ°´ä½å‘Šè­¦ã€‚ çœŸæ˜¯è§é¬¼ï¼Œä»¥å¾€çš„æ’æŸ¥æ–¹å¼å±…ç„¶æ²¡æœ‰ä¸€ä¸çº¿ç´¢\u0026hellip; äºæ˜¯æˆ‘è§‰å¾—è‡ªå·±åŠ ä¸Šè€—æ—¶æ‰“ç‚¹ï¼Œç„¶åé€šè¿‡è„šæœ¬é‡‡é›†ä¸‹è€—æ—¶æƒ…å†µã€‚  é‡‡é›†  æ¥å£åŠ å…¥æ‰“ç‚¹ç»Ÿè®¡ä¸åŒæœºå™¨ä¸Šçš„mgetè€—æ—¶ï¼Œredisæœªå‘½ä¸­æ•°ï¼Œ dbå¹¶å‘æŸ¥è¯¢è€—æ—¶ åœ¨è´Ÿè½½ä¸é«˜çš„æœºå™¨åˆ†å›ºå®šuid è·Ÿéšæœºuidä¸¤ç»„è¯·æ±‚æ¥å£è·å–è€—æ—¶æ•°æ®ï¼ŒåŒæ—¶æœ¬åœ°ç›´æ¥è¿æ¥redisè°ƒç”¨mgetç»Ÿè®¡è€—æ—¶ã€‚  æ•°æ®åˆ†æ  è®¡ç®—æ¯åˆ†é’Ÿå„é¡¹æ•°æ®è€—æ—¶çš„å¹³å‡å€¼(è¿™é‡Œèµ°äº†ä¸ªå¼¯è·¯ğŸ˜°) å¯¹æ¯”ä¸åŒæœºå™¨ä¸Šçš„mgetè€—æ—¶ï¼Œçœ‹æ˜¯ä¸æ˜¯ä¸ªåˆ«æœºå™¨çš„é—®é¢˜ã€‚ å¯¹æ¯”åŒæ—¶éœ€è¦è¯·æ±‚Redisè·ŸDBæ—¶ï¼Œäº†è§£mgetè·Ÿdbçš„è€—æ—¶åå·®ã€‚ å¯¹æ¯”æœåŠ¡mgetè·Ÿæœ¬åœ°mgetè€—æ—¶ï¼ŒéªŒè¯Redisè€—æ—¶æƒ…å†µæ˜¯å¦å¦‚å®ã€‚  ä»¥ä¸‹å›¾æ ‡xè½´ä¸ºæ—¶é—´ï¼ˆåˆ†é’Ÿçº§ï¼‰yè½´ä¸ºè€—æ—¶ï¼ˆå•ä½ms) ä¸Šé¢è¿™å¼ å°±æ˜¯ä¸åŒæœºå™¨çš„mgetè€—æ—¶æƒ…å†µï¼Œå¯ä»¥çœ‹å‡ºmgetè€—æ—¶ç¡®å®å­˜åœ¨é«˜å³°æœŸæ•ˆåº”å¹¶ä¸”ä¸å­˜åœ¨ä¸ªåˆ«æœºå™¨è€—æ—¶åç¦»è¾ƒå¤§çš„æƒ…å†µï¼Œæ‰€ä»¥æ’é™¤ä¸ªåˆ«æœºå™¨çš„é—®é¢˜ã€‚\nåœ¨åŒæ—¶éœ€è¦æŸ¥Redisè·ŸDBçš„è¯·æ±‚ä¸­ï¼ŒDBè€—æ—¶æ˜æ˜¾é«˜äºRedis,ä½†è¿™æ˜¯å¯é¢„è§çš„ï¼Œé«˜ä½å³°ä¸¤ä¸ªæ›²çº¿çš„æ³¢åŠ¨ä»è¿™ä¸ªå›¾ä¸Šçœ‹ä¸æ˜æ˜¾ï¼Œè¿›ä¸€æ­¥é€šè¿‡æŠ½æŸ¥æœåŠ¡çš„æ‰“ç‚¹æ—¥å¿—å¯ä»¥çœ‹åˆ°3ä¸‡ä¸ªè¯·æ±‚ä¸­éœ€è¦æŸ¥è¯¢DBçš„åªæœ‰16ä¸ªï¼Œè¯´æ˜feedæµè·å–çš„ç”¨æˆ·åŸºæœ¬éƒ½æ˜¯ç¼“å­˜åˆ°Redisçš„çƒ­æ•°æ®ï¼Œæ’é™¤DBå¼•å‘é«˜è€—æ—¶,è¿›ä¸€æ­¥è§‚å¯ŸRedisçš„æ•°æ®ã€‚\nä¸Šé¢è¿™å¼ å›¾å·¦è¾¹æ˜¯å‡ºé—®é¢˜çš„æœåŠ¡å†…éƒ¨mgetï¼Œå³è¾¹æ˜¯ä½è´Ÿè½½æœåŠ¡å™¨ä¸Šä½¿ç”¨åŒä¸ªRedisé›†ç¾¤çš„mgetè¡¨ç°ã€‚ä¸¤è€…å‘ˆç°ç›¸åŒçš„åˆ†å¸ƒè¶‹åŠ¿ï¼ŒRedisé«˜å³°æœŸç¡®å®å“åº”å˜æ…¢ã€‚\né€šè¿‡ä»¥ä¸Šçš„ä¸€è½®åˆ†æï¼Œé¦–å…ˆæ’é™¤äº†ä¸ªåˆ«æœºå™¨çš„é—®é¢˜ä»¥åŠDBçš„é—®é¢˜ï¼Œä¼¼ä¹é—®é¢˜å°±æ˜¯Redisæ…¢äº†å¯¼è‡´çš„ã€‚ä½†æ˜¯ï¼Œä¸å¯¹å•Šï¼ŒRedisè€—æ—¶è™½ç„¶é«˜å³°æœŸå˜æ…¢ä½†æ˜¯8msä¹Ÿå¹¶ä¸è‡³äºå¯¼è‡´100+msçš„å‘Šè­¦ï¼Œå¦å¤–Redisçš„æ€§èƒ½æ˜¯å¤§å®¶å…¬è®¤çš„ã€‚ åé¢ç»è¿‡å’ŒåŒäº‹çš„ä¸€ç•ªæ¢è®¨ï¼Œæ”¶è·äº†ä¸€ä¸ªé‡è¦çš„çŸ¥è¯†\u0026ndash;æ’æŸ¥é—®é¢˜çš„æ—¶å€™ä¸€èˆ¬çœ‹æœ€å¤§å€¼ï¼Œå¦å¤–ä¹Ÿè¿˜å‘ç°æˆ‘æ¼åˆ†æäº†ä¸­è½¬çš„è€—æ—¶ã€‚\nä¸Šé¢è¿™å¼ å°±æ˜¯åæ¥è¡¥çš„ä¸­è½¬è€—æ—¶è¶‹åŠ¿å›¾ï¼ˆæŒ‰æ¯åˆ†é’Ÿå–æœ€å¤§å€¼å¤„ç†ï¼‰ï¼Œä¸­è½¬æœ€å¤§è€—æ—¶ä¹Ÿä¸è¿‡2msï¼Œæ˜¾ç„¶ä¹Ÿä¸æ˜¯ä¸­è½¬å¯¼è‡´çš„ã€‚\nç»§ç»­å¯¹ä¹‹å‰çš„æ•°æ®åšæœ€å¤§å€¼å¤„ç†ï¼Œåœ¨æœåŠ¡ç«¯mgetè·Ÿæœ¬åœ°mgetè¿™ç»„é˜Ÿæ¯”ä¸­æˆ‘ä»¬å‘ç°äº†å¼‚å¸¸ğŸ‘‡\nåœ¨å–æœ€å¤§å€¼çš„æƒ…å†µä¸‹ï¼ŒæœåŠ¡çš„mgetè€—æ—¶é«˜å³°æœŸæ™®éåˆ°è¾¾80msä»¥ä¸Šï¼Œè€Œç›´æ¥è¿Redisçš„å¯¹ç…§ç»„åˆ™ååˆ†å¹³ç¨³æ²¡æœ‰é«˜å³°æ•ˆåº”ã€‚è¿™ååˆ†è®©äººä¸è§£ï¼Œæˆ‘çš„è„šæœ¬è¿æ¥Redisè·ŸæœåŠ¡å™¨çš„è¡¨ç°å®Œå…¨å¯¹ä¸ä¸Šäº†ï¼Œå¤ªå¥‡æ€ªäº†ï¼Œæ˜¯æ—¶å€™åˆ†æä¸‹ä»£ç äº†ã€‚\næŸ¥çœ‹ä»£ç   æˆ‘çš„è„šæœ¬è·ŸæœåŠ¡å™¨éƒ½æ˜¯é€šè¿‡è¿™æ ·çš„æ–¹å¼è·å–Rediså®¢æˆ·ç«¯ï¼Œè¿™ä¸ªå®¢æˆ·ç«¯åˆ°åº•æ˜¯æ€ä¹ˆç”Ÿæˆçš„å‘¢ï¼Ÿoptioné‡Œåˆ°åº•æœ‰ä»€ä¹ˆï¼Ÿ   é€šè¿‡å¯¹ä»£ç çš„è¿›ä¸€æ­¥æŸ¥çœ‹ï¼Œå‘ç°è¿™ä¸ªRediså®¢æˆ·ç«¯æ˜¯ç»´æŠ¤äº†ä¸€ç»„Redisé“¾æ¥æ± çš„ï¼Œå¹¶ä¸”é€šè¿‡è¿™ä¸ªpoolSizeçš„å‚æ•°è®¾ç½®é“¾æ¥æ± çš„å¤§å°ï¼Œé»˜è®¤å¤§å°æ˜¯10*CPUæ•°ã€‚è¿™ä¸‹æˆ‘ä»¬æœ‰äº†çº¿ç´¢ï¼Œåˆæ­¥æ€€ç–‘è¿æ¥ä¸å¤Ÿç”¨ï¼Œç»§ç»­çœ‹ä»£ç ï¼Œå‘ç°è¿æ¥æ± æ— ç©ºé—²è¿æ¥çš„æ—¶å€™é»˜è®¤çš„ç­‰å¾…è¶…æ—¶å±…ç„¶è¾¾1ç§’é’Ÿï¼Œè¿™æ›´åŠ å†³å®šäº†æˆ‘çš„æ€€ç–‘ï¼Œåç»­æˆ‘åŠ äº†ä¸ªç©ºé—²è¿æ¥æ•°çš„å¸¦ç‚¹ä¹Ÿç¡®å®éªŒè¯äº†é«˜å³°æœŸè¿æ¥æ•°è€—å°½çš„æƒ…å†µã€‚  è§£å†³  ä¿®æ”¹é»˜è®¤è¿æ¥æ± æ•°ç›®ï¼Œå› ä¸ºé€šè¿‡ä»£ç å‘ç°è¿™ä¸ªè¿æ¥æ•°æ˜¯æœ‰è‡ªåŠ¨å›æ”¶æœºåˆ¶çš„ï¼Œè¿æ¥ç©ºé—²è¶…è¿‡ä¸€å®šæ—¶é—´å°±ä¼šè¢«å›æ”¶ã€‚  æ€»ç»“  é‡‡ç”¨è€—æ—¶æ‰“ç‚¹çš„æ–¹å¼å¯ä»¥å¾ˆå¿«å®šä½é—®é¢˜çš„ä½ç½®ã€‚ è®¾ç½®åˆç†çš„å¯¹ç…§ç»„æœ‰åˆ©äºä½“ç°æ•°æ®å¼‚å¸¸ä»ä¸­æ‰¾åˆ°çº¿ç´¢ã€‚ åˆ†ææ€§èƒ½é—®é¢˜æ—¶è¦çœ‹æœ€å¤§å€¼ï¼Œå¹³å‡å€¼ä¼šæ©ç›–æ‰çœŸå®æƒ…å†µã€‚ æœ€åè¦è€å¿ƒåœ°åˆ†æä»£ç å°è¯•åˆ°æ•°æ®èƒŒåçš„çœŸç›¸ã€‚  ","date":"2020-07-31","permalink":"/posts/record-server-optimization/","tags":["redis"],"title":"è®°ä¸€æ¬¡æœåŠ¡ç«¯æ€§èƒ½ä¼˜åŒ–"},{"content":"SSHæ˜¯ä»€ä¹ˆ ssh æ˜¯ä¸€ç§åŠ å¯†ç½‘ç»œåè®®ï¼Œé€šè¿‡å»ºç«‹å®‰å…¨éš§é“æ¥è¿›è¡Œå®¢æˆ·ç«¯/æœåŠ¡å™¨é€šä¿¡ï¼Œé€šå¸¸ç”¨äºè¿œç¨‹ç™»å½•ï¼Œä½†å®é™…ä¸Šä»»ä½•ç½‘ç»œæœåŠ¡éƒ½å¯ä»¥é€šè¿‡sshè¿›è¡Œå®‰å…¨ä¼ è¾“ã€‚\nåˆ©ç”¨SSH è¿›è¡Œç§‘å­¦ä¸Šç½‘  å¦‚æœä½ æ°å·§æœ‰ä¸€å°æµ·å¤–æœåŠ¡å™¨ï¼Œå¯ä»¥åˆ©ç”¨sshè¿›è¡ŒåŠ¨æ€ç«¯å£è½¬å‘ä»è€Œå®ç°ç§‘å­¦ä¸Šç½‘ã€‚ ssh -p your_ssh_port -f -N -D 0.0.0.0:8000 username@remote_host è¿™ä¸ªå‘½ä»¤å¯åŠ¨socketç›‘å¬æœ¬åœ°ç«¯å£8000,å°†æ‰€æœ‰å‘é€åˆ°çš„æ•°æ®é€šè¿‡sshåè®®ä¸è¿œç¨‹ä¸»æœºè¿›è¡Œé€šä¿¡ã€‚ å¼€å¯åŠ¨æ€ç«¯å£è½¬å‘åï¼Œé€šè¿‡SwitchyOmegaç­‰ä»£ç†æ’ä»¶å°†æµè§ˆå™¨æ•°æ®è½¬å‘åˆ°æœ¬åœ°ç«¯å£8000å³å¯ã€‚ å®šæ—¶é‡å¯è„šæœ¬ã€‚ä¸çŸ¥é“æ˜¯ä¸æ˜¯è¶…æ—¶é…ç½®é—®é¢˜ï¼Œsshä¼šæ—¶ä¸æ—¶æ–­çº¿ï¼Œéœ€è¦é‡å¯ï¼Œæ‰€ä»¥å°±å†™äº†ä¸ªpythonè„šæœ¬åŠ åˆ°crontabã€‚  import subprocess import os import re ''' é€šè¿‡ ps -ef | grep ssh\\ -p\\ 22\\ -f\\ -N | grep -v grep | awk '{print $2}' æ‰¾åˆ°å¯åŠ¨çš„è¿›ç¨‹ï¼Œæ‰§è¡Œ killï¼Œ é‡å¯sshè½¬å‘å‘½ä»¤ã€‚ ''' try: ps = subprocess.Popen(('ps', '-ef'), stdout=subprocess.PIPE) grep = subprocess.Popen(('grep', 'ssh\\ -p\\ 22\\ -f\\ -N' ), stdin=ps.stdout, stdout=subprocess.PIPE) awk = subprocess.check_output(('awk', '{print $2}'), stdin=grep.stdout) ps.wait() grep.wait() print(awk) except: command = \u0026quot;ssh -p 22 -f -N -D 0.0.0.0:8000 username@remote_ip\u0026quot; os.system(command) exit() pids = [p for p in awk.split('\\n') if re.match(\u0026quot;^\\d\u0026quot;, p)] for pid in pids: print(\u0026quot;to kill...%s\u0026quot; % (pid)) subprocess.check_output([\u0026quot;kill\u0026quot;, pid]) command = \u0026quot;ssh -p 22 -f -N -D 0.0.0.0:8000 username@remote_ip\u0026quot; os.system(command)   ç”¨shell æ›´å°‘ä»£ç   #!/usr/bin pids=(`ps -ef | grep 'ssh -p 22 -f -N' | grep -v 'grep' | awk '{print $2}'`) echo $pids for p in $pids do kill -9 $p\tdone ssh -p 22 -f -N -D 0.0.0.0:1090 root@remote_ip  ","date":"2019-06-10","permalink":"/posts/access-google/","tags":["ssh"],"title":"ç§‘å­¦ä¸Šç½‘ä¹‹ssh"},{"content":"è®°å½•Java8çš„ä¸€äº›è¯­æ³•ğŸ¬\nList to Map @Data @AllArgsConstructor @ToString class People { private String name; private int age; private String lastName; } @Test public void testStream() { List\u0026lt;People\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(new People(\u0026quot;nautilis\u0026quot;, 25, \u0026quot;zheng\u0026quot;)); list.add(new People(\u0026quot;nautilis\u0026quot;, 25, \u0026quot;zheng\u0026quot;)); list.add(new People(\u0026quot;bevan\u0026quot;, 25, \u0026quot;zheng\u0026quot;)); list.add(new People(\u0026quot;ning\u0026quot;, 24, \u0026quot;li\u0026quot;)); //é‡å¤keyåªä¿ç•™ä¸€ä¸ªï¼Œ å¹¶ç”¨linkedHashMapä¿è¯é¡ºåº Map\u0026lt;String, People\u0026gt; map = list.stream().sorted(Comparator.comparing(People::getAge).reversed()) .collect(Collectors.toMap(People::getName, Function.identity(), (oldv, newV) -\u0026gt; newV, LinkedHashMap::new )); System.out.printf(\u0026quot;é‡å¤keyåªä¿ç•™ä¸€ä¸ªï¼Œ å¹¶ç”¨linkedHashMapä¿è¯é¡ºåº---\u0026gt;\u0026quot;); map.forEach((k, v) -\u0026gt; System.out.println(k + \u0026quot;:\u0026quot; + v)); //å§“æ°#=\u0026gt;äººåˆ—è¡¨ Map\u0026lt;String,List\u0026lt;People\u0026gt;\u0026gt; lastPeopleMap = list.stream() .collect(Collectors.groupingBy(People::getLastName)); System.out.println(\u0026quot;å§“æ°#=\u0026gt;äººåˆ—è¡¨ ---\u0026gt;\u0026quot;); lastPeopleMap.forEach((k, v) -\u0026gt; System.out.println(k + \u0026quot; : \u0026quot; + v)); //å§“æ°#=\u0026gt; äººååˆ—è¡¨ Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; lastnameNamelistMap = list.stream() .collect(Collectors.groupingBy(People::getLastName, Collectors.mapping(People::getName, Collectors.toList()))); System.out.println(\u0026quot;å§“æ°#=\u0026gt; äººååˆ—è¡¨---\u0026gt;\u0026quot;); lastnameNamelistMap.forEach((k, v) -\u0026gt; System.out.println(k + \u0026quot; : \u0026quot; + v)); // å§“æ°#=\u0026gt;äººåé›†åˆ Map\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt; lastnameNameSet = list.stream() .collect(Collectors.groupingBy(People::getLastName, Collectors.mapping(People::getName, Collectors.toSet()))); System.out.println(\u0026quot;å§“æ°#=\u0026gt;äººåé›†åˆ---\u0026gt;\u0026quot;); lastnameNameSet.forEach((k, v) -\u0026gt; System.out.println(k + \u0026quot; : \u0026quot; + v)); }  ","date":"2019-05-18","permalink":"/posts/java8/","tags":["Java"],"title":"Java8è¯­æ³•ç³–"},{"content":" ç«¯å£è½¬å‘Â http://www.dshowing.com/2017/08/14/SSH_portforward/Â æœ¬åœ°å¯åŠ¨ssh:ssh -p [serverport] -f -N -D 0.0.0.0:[socksport] username@remoteaddressÂ chromeä¸Šç”¨proxy switchysharp æˆ–è€… firefox ç”¨FoxyProxy é…ç½®ä¸€ä¸ªsocks5 IP:127.0.0.1 ç«¯å£ä¸ºæ‰€å¡«çš„socksportã€‚ ssh -o PubkeyAuthentication=no 120.24.161.131  ä¸ç”¨ssh key ssh -f åå°è¿è¡Œ -N ä¸å‘é€å‘½ä»¤ -f -N å‚æ•° ssh -f -N -L localport:host1:port1 host3 host2æ‰§è¡Œæ­¤å‘½ä»¤ï¼Œ host2ç™»å½•host3 æœ¬åœ°ç«¯å£è½¬å‘ -L æ¥è‡ªhost3èµ°localhostçš„æ•°æ®å‘é€åˆ°host1çš„port1 è¿œç¨‹ç«¯å£è½¬å‘ ssh -f -N -R remotePort:host1:port1 host3 åœ¨host2æ‰§è¡Œæ­¤å‘½ä»¤è¡¨ç¤º åœ¨host2ç™»å½•host3 ä»¤ host3ç›‘å¬ remotePort, host2å°†host3å‘åˆ° remotePort çš„æ•°æ®è½¬å‘åˆ°host1:prot1 æœ¬åœ°ç«¯å£è½¬å‘ä½¿ç”¨åœºæ™¯ host3å¯ä»¥è¿host2, host2èƒ½è¿host1,host3ä¸èƒ½è®¿é—®host1, å¯é€šè¿‡host2åšæœ¬åœ°ç«¯å£è½¬å‘ã€‚ è¿œç¨‹ç«¯å£è½¬å‘ï¼Œç”¨äºå†…ç½‘ç©¿é€ï¼Œ host1 host2åœ¨å†…ç½‘ï¼Œhost2å¯è®¿é—®å¤–ç½‘çš„host3, host3æ— æ³•è®¿é—®å†…ç½‘ï¼Œå¯ä»¥åœ¨host2åšè¿œç¨‹ç«¯å£è½¬å‘ï¼Œä½¿host3çš„æ•°æ®å‘é€åˆ°å†…ç½‘ã€‚ ssh -f -N -L localport:localhost:port host3 localhostæŒ‡çš„æ˜¯host3, localhost æ˜¯ç›¸å¯¹host3çš„ã€‚  ","date":"2019-03-21","permalink":"/posts/ssh-note/","tags":["ssh"],"title":"ssh ç¬”è®°"},{"content":"å½’å¹¶æ’åº  å½’å¹¶æ’åºæ˜¯å»ºç«‹åœ¨å½’å¹¶æ“ä½œçš„åŸºç¡€ä¹‹ä¸Šçš„ã€‚å¦‚æœä¸¤ä¸ªæ•°ç»„éƒ½æ˜¯æœ‰åºæ•°ç»„ï¼Œåªéœ€è¿­ä»£ä¸¤ä¸ªæ•°ç»„ï¼Œä¸æ–­æ¯”è¾ƒä¸¤ä¸ªæ•°ç»„å…ƒç´ ï¼Œå°†è¾ƒå°çš„æ’åˆ°å‰é¢å³å¯ã€‚å½’å¹¶æ’åºé¦–å…ˆé€šè¿‡é€’å½’å¯¹æ•°ç»„è¿›è¡Œå¯¹ç­‰åˆ†å‰²ï¼Œç›´åˆ°åˆ†å‰²çš„éƒ¨åˆ†åªæœ‰ä¸€ä¸ªå…ƒç´ (ç›¸é‚»ä¸¤ä¸ªæ•°ç»„å¿…å®šæœ‰åºï¼‰è¿›è¡Œåˆå¹¶æ“ä½œã€‚  #include\u0026lt;stdio.h\u0026gt; void show(int arr[], int n){ int i; for( i=0; i\u0026lt;n; i++) printf(\u0026quot;%d, \u0026quot;, arr[i]); printf(\u0026quot;\\n\u0026quot;); }\t//åˆå¹¶ç®—æ³• void merge(int array[], int left, int mid, int right){ int aux[right+1]; //ä¸´æ—¶æ•°ç»„ //ä»ä¸­é—´æ–­å¼€ä¸¤ä¸ªæ ‡å¿—åˆ†åˆ« int i = left; int j = mid + 1; int k; for( k=left; k\u0026lt;=right; k++ ) //å¤åˆ¶æ•°ç»„ aux[k] = array[k]; for( k=left; k\u0026lt;=right; k++ ){ if(i \u0026gt; mid) //å·¦è¾¹æŒ‡é’ˆå·²è¶…å‡º array[k] = aux[j++]; else if(j \u0026gt; right) //å³è¾¹æŒ‡é’ˆè¶…å‡º array[k] = aux[i++]; else if(aux[j] \u0026lt; aux[i]) //éƒ½æ²¡æœ‰è¶…å‡ºå°±æ¯”è¾ƒä¸¤è€…å¤§å° array[k] = aux[j++]; else array[k] = aux[i++]; } } void sort(int array[], int left, int right){ if(left \u0026gt;= right) return;\tint mid = left + (right - left) / 2; sort(array, left, mid); sort(array, mid+1, right); merge(array, left, mid, right); } int main() { int arr_test[] = { 8, 2, 19, 4, 5, 11, 23, 44, 12, 31 }; int size = sizeof(arr_test)/sizeof(arr_test[0]); printf(\u0026quot;%s \\n\u0026quot;, \u0026quot;before sort:\u0026quot;); show(arr_test, size); sort(arr_test, 0, size-1);\tprintf(\u0026quot;%s \\n\u0026quot;, \u0026quot;after sorted:\u0026quot;); show(arr_test, size); return 0; }  å¿«é€Ÿæ’åº  å¿«é€Ÿæ’åºæ˜¯å»ºç«‹åœ¨åˆ’åˆ†åŸºç¡€ä¸Šçš„ï¼Œåˆ’åˆ†è¿‡ç¨‹é€‰å–ä¸€ä¸ªæ•°ç»„æˆå‘˜ä½œä¸ºæ¯”è¾ƒå°†æ•°ç»„åˆ’åˆ†æˆå¤§äºè¿™æ¯”è¾ƒç›®æ ‡å’Œå°äºè¿™ä¸ªæ¯”è¾ƒç›®æ ‡çš„ä¸¤éƒ¨åˆ†,å¯¹æ•°ç»„ä¸æ–­çš„é€’å½’åˆ’åˆ†æœ€ç»ˆæ•°ç»„å³æ˜¯æœ‰åºçš„ã€‚  #include\u0026lt;stdio.h\u0026gt; void show(int arr[], int size) { int i; for(i=0;i\u0026lt;size;i++) printf(\u0026quot;%d \u0026quot;, arr[i]); printf(\u0026quot;\\n\u0026quot;); } void exch(int arr[], int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } int partition(int arr[], int left, int right) { int v = arr[left]; int i = left; //å‘å‰æ‰«çš„æŒ‡é’ˆ int j = right + 1; //å‘åæ‰«æŒ‡é’ˆ while(1){ while(arr[++i] \u0026lt; v) if(i == right)//å‰æ‰«æŒ‡é’ˆå·²åˆ°ä½ break; while(arr[--j] \u0026gt; v) if(j == left) //åæ‰«æŒ‡é’ˆå·²åˆ°ä½ break; if(i\u0026gt;=j)// ä¸¤ä¸ªæŒ‡é’ˆç›¸é‡ break;\texch(arr, i, j); //while å¾ªç¯åœä¸‹æ¥äº¤æ¢å…ƒç´  } exch(arr, left, j); return j; } void sort(int arr[], int left, int right) { if(left \u0026gt;= right) return; int j = partition(arr, left, right); sort(arr, left, j); sort(arr, j+1, right); } void quickSort(int arr[], int size) { sort(arr, 0, size -1); } int main() { int arr[] = {23, 11, 24, 5, 67, 2, 4}; int size = sizeof(arr) / sizeof(arr[0]); show(arr, size); quickSort(arr, size); show(arr, size); }  ","date":"2018-07-07","permalink":"/posts/sort-algorithm/","tags":["sort"],"title":"æ’åºç®—æ³•"}]